#include<stdio.h>


//代码需要有唯一的计算路径。
//代码5   error     
int main()
{
	int i = 1;
	int ret = (++i) + (++i) + (++i);
	printf("%d\n", ret);   //14   
	printf("%d\n", i);   //4
	return 0;
}//尝试在linux 环境gcc编译器，VS2013环境下都执行，看结果   10  4


////代码4
//int fun()
//{
//    static int count = 1;
//    return ++count;
//}
//int main()
//{
//    int answer; 
//    answer = fun() - fun() * fun();    //哪个fun()先调用？  error
//    printf("%d\n", answer);//输出多少？   
//    return 0;
//}




//一些问题表达式
//表达式的求值部分由操作符的优先级决定。
//表达式1
//a* b + c * d + e * f   //是优先级并不能决定第三个* 比第一个 + 早执行。
//表达式2
//c + --c;   //+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的。
//代码3-非法表达式
//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i = %d\n", i);
//	return 0;  //表达式3在不同编译器中测试结果：非法表达式程序的结果
//}



////优先级
//int main()
//{
//	int a = 0;
//	int b = 20;
//	int c = b + a * 3;   
//	int c = b + a + 3;  
//	return 0;
//}



////算术转换   int ->float
////某个操作数的类型在上面这个列表中排名较低,那么首先要转换为另外一个操作数的类型后执行运算。警告： 但是算术转换要合理，要不然会有一些潜在的问题
//float f = 3.14;
//int num = f;//隐式转换，会有精度丢失

////实例2
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));     //1  //%u 无符号10进制整数   %c 单个字符  	%s 字符串
//	printf("%u\n", sizeof(+c));   //4     //c只要参与表达式运算,就会发生整形提升
//	printf("%u\n", sizeof(!c));  //1
//	return 0;
//}


////整型提升案例
//int main()
//{
//	char a = 0xb6;
//	//10110110
//	//11111111111111111111111110110110
//	short b = 0xb600;  //整型提升
//	int c = 0xb6000000;
//	if (a == 0xb6)
//	printf("a");
//	if (b == 0xb600)
//	printf("b");
//	if (c == 0xb6000000)
//	printf("c");    //只打印c
//	return 0;
//}


////隐式类型转换
////表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。
////整形提升是按照变量的数据类型的 符号位 来提升的
//int main()
//{
//	char a = 3;
//	//00000000000000000000000000000011
//	//00000011 -a  最小最低位的字节
//	char b = 127;
//	//00000000000000000000000001111111
//	//01111111  -b
//	//a和b如何相加？
//	char c = a + b;
//	//00000000000000000000000000000011
//	//00000000000000000000000001111111
//	//00000000000000000000000010000010
//	//截断   10000010 -c
//	//11111111111111111111111110000010  补码   整型提升补1
//	//11111111111111111111111110000001  反码
//	//10000000000000000000000001111110  原码
//	//-126
//	printf("%d\n",c);  //-126
//	return 0;
//}



////下标引用、函数调用和结构成员
////访问一个结构的成员
////. 结构体.成员名
////->结构体指针->成员名
//
////学生
////int float
////创建有一个结构体类型- struct Stu
//struct Stu
//{
//	//成员变量
//	char name[20];
//	int age;
//	char id[20];
//};
//
//int main()
//{
//	//int a = 10;
//	//使用struct Stu这个类型创建了一个学生对象s1，并初始化
//	struct Stu s1 = {"张三",20,"2019010305"};
//	struct Stu* ps = &s1;
//
//	printf("%s\n", ps->name);  //ps所指向对象的成员
//	printf("%d\n", ps->age);
//	//结构体指针 -> 成员名
//
//	//printf("%s\n", (*ps).name);
//	//printf("%d\n", (*ps).age);
//
//
//	//printf("%s\n", s1.name);
//	//printf("%d\n", s1.age);
//	//printf("%s\n", s1.id);
//	////结构体变量.成员名
//	return 0;
//}


////( ) 函数调用操作符
//// 接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。
//int get_max(int x, int y)
//{
//	return x > y ? x : y;
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//调用函数的时候()就是函数调用操作符
//	int max = get_max(a, b);
//	printf("%d\n",max);
//	return 0;
//}


//[]下标引用操作符
//int main()
//{
//	int a[10] = { 0 };
//	a[9] = 10; //  实用下标引用操作符。  操作数：一个数组名 + 一个索引值
// 	//[ ]的两个操作数是arr和9。
//	return 0;
//}


////逗号表达式：就是用逗号隔开的多个表达式。 
////逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。
//int main()
//{
//    //代码1
//    int a = 1;
//    int b = 2;
//    int c = (a > b, a = b + 10, a, b = a + 1);//  b=13  逗号表达式
//   // c是多少？
//       
//    ////代码2
//    //if(a = b + 1, c = a / 2, d > 0)
//    ////代码3
//    //a = get_val();
//    //count_val(a);
//    //while (a > 0)
//    //{
//    //    //业务处理
//    //    a = get_val();
//    //    count_val(a);
//    //}
//    ////如果使用逗号表达式，改写：
//    //while (a = get_val(), count_val(a), a > 0)
//    //{
//    //    //业务处理
//    //}
//	return 0;
//}


////条件操作符(三目操作符)
////exp1 ? exp2 : exp3
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int max = 0;
//	//if (a > b)
//	//	max = a;
//	//else
//	//	max = b;
//
//	//max = (a > b ? a : b);
//
//	//if (a > 5)
//	//	b = 3;
//	//else
//	//	b = -3;
//
//	//b = (a > 5 ? 3 : -3);
//
//	return 0;
//}

//int main()
//{
//    int i = 0, a = 0, b = 2, c = 3, d = 4;
//    //i = a++ && ++b && d++;    //第一个为假，逻辑与其后都不用算了  1 2 3 4   
//
//    i = a++||++b||d++;     //1 3 3 4   遇到真，逻辑或后面就不用算了
//    printf("a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);  
//    return 0;
//    //程序输出的结果是什么？
//}



////逻辑操作符
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a && b;  
//	int c = a || b;
//	printf("%d\n",c);   //1 
//
//	return 0;
//}


//在编程的过程中== 和=不小心写错，导致的错误。  
//  == 等于   !=不等于

//int main()
//{
//	int a = (int)3.14;    //int a = int(3.14)  error
//
//	return 0;
//}


//int main()
//{
//	int a = 10;
//	//printf("%d\n",++a);   //前置++，先++，后使用   11
//	printf("%d\n",a++);   //后置++  先使用，再++   10
//	printf("%d\n",a);   //11
//	return 0;
//}


//int main()
//{
//	int a = 11;
//	a = a | (1 << 2);
//	printf("%d\n",a);  //15
//	a = a & (~(1 << 2));
//	printf("%d\n", a);   //11
//	//00000000000000000000000000001011   
//	//00000000000000000000000000000001   1<< 2
//	//00000000000000000000000000000100  或一下   
//	//00000000000000000000000000001111  //15
//
//	//00000000000000000000000000001111    
//	//11111111111111111111111111111011     按位与  1移位在取反
//	//00000000000000000000000000001011    //11
//
//
//
//	//int a = 0;
//	////~按(2进制)位取反
//	////00000000000000000000000000000000
//	////11111111111111111111111111111111   补码
//	////11111111111111111111111111111110  反码
//	////10000000000000000000000000000001  原码  -1
//	//printf("%d\n",~a);   //-1
//
//	return 0;
//}



////sizeof
//int main()
//{
//	short s = 0;
//	int a = 10;
//	printf("%d\n",sizeof(s = a + 5));   //2  short ->2个字节  sizeof()不会真正运算的
// 	printf("%d\n",s);  //0  
//	return 0;
//}


//void test1(int arr[])
//{
//	printf("%d\n", sizeof(arr));//(2)   4
//}
//void test2(char ch[])
//{
//	printf("%d\n", sizeof(ch));//(4)   4  传递的是首元素地址  指针的大小
//}
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("%d\n", sizeof(arr));//(1)   40
//	printf("%d\n", sizeof(ch));//(3)  10
//	test1(arr);
//	test2(ch);
//	return 0;
//}


////单目操作符 - 只有一个操作符
////a +  b   +双目操作符
//int main()
//{
//	int a = 10;
//	char c = 'r';
//	char* p = &c;
//	int arr[10] = { 0 };
//	//sizeof计算的是变量所占空间的大小，单位是字节
//	printf("%d\n",sizeof(a));  //4    a 的括号可省略
//	printf("%d\n",sizeof(int));
//	//printf("%d\n", sizeof int);   error  类型的时候不能省略括号
//
//	printf("%d\n",sizeof(c));  //1
//	printf("%d\n", sizeof(char));
//
//	printf("%d\n",sizeof(p));   //4
//	printf("%d\n", sizeof(char*));
//
//	printf("%d\n",sizeof(arr));  //40  4*10=40
//	printf("%d\n", sizeof(int [10]));  //int [10]  就是数组类型;  去掉数组名
//
//
//	//int a = 10;
//	//int* p = &a; //取地址操作符
//	//*p = 20; //解引用操作符
//	
//
//	//int a = -5;
//	//a = -a;
//	//printf("%d",a);
//
//	//int a = 10;
//	//if (a)   //a为真打印
//	//{
//	//	printf("hehe\n");
//	//}
//	//if (!a)   //a为假打印
//	//{
//	//	printf("hehe\n");
//	//}
//	////printf("%d",!a);   //0
//
//	return 0;
//}




////赋值操作符
//int main()
//{
//	int a = 10;
//	a = a + 2;
//	a += 2;//复合赋值符
//	
//	a = a >> 1;
//	a >>= 1;
//
//	a = a & 1;
//	a *= 1;
//
//	return 0;
//}

//a = x = y+1;//连续赋值
//x = y+1;
//a = x;   这样的写法更加清晰爽朗而且易于调试。


////编写代码实现：求一个整数存储在内存中的二进制中1的个数.
////123
//int main()
//{
//	int num = 0;
//	int count = 0;  
//	scanf("%d",&num);  //3 - 011  
//	
//	{
//		int num = -1;
//		int i = 0;
//		int count = 0;//计数
//		while (num)
//		{
//			count++;
//			num = num & (num - 1);
//		}
//		printf("二进制中1的个数 = %d\n", count);
//		return 0;
//	}
//
//					   
//	////32bit
//	////00000000000000000000000000000011
//	////00000000000000000000000000000001  按位与1
//	////00000000000000000000000000000001
//	////num % 1 == 1;
//	//int i = 0;
//	//for (i = 0; i < 32; i++)
//	//{
//	//	if (((num >> i) & 1) == 1)
//	//		count++;
//	//}
//
//
//
//
//	////统计num的补码中有几个1
//	//while (num)   //-1  负数出现bug
//	//{
//	//	if (num % 2 == 1)  
//	//		count++;
//	//	num = num / 2;
//	//}
//
//
//
//	printf("二进制中1的个数 = %d\n", count);
//	return 0;
//}




////位操作符
//// & 按位与  (二进制位)
//// | 按位或
//// ^ 按位异或
////注：他们的操作数必须是整数。
//
////不能创建临时变量（第三个变量），实现两个数的交换。
//int main()
//{
//	int a = 3;
//	int b = 5;
//	//int tmp = 0;//临时变量
//	printf("before:a = %d ,b = %d\n", a, b);
//	/*tmp = a;
//	a = b;
//	b = tmp;*/
//
//	////加减法 - 可能会溢出  （数超级大的时候）
//	//a = a + b;
//	//b = a - b;   //将原来a放到b中
//	//a = a - b;   // 得到原来b值放到a中
//
//	//异或的方法
//	a = a ^ b;   //011  101  -> 110   6
//	b = a ^ b;   //110  101  -> 011   3
//	a = a ^ b;   //110  011  -> 101   5
//
//
//	printf("after:a = %d ,b = %d\n",a,b);
//	return 0;
//}



//int main()
//{
//	//// & 按位与  (二进制位)
//	//int a = 3;  //011   补码进行运算
//	//int b = 5;  //101
//	//int c = a & b;  //001
//	//printf("%d\n",c);   //1
//
//	//// | 按位或
//	//int a = 3;  //011
//	//int b = 5;   //101
//	//int c = a | b;  //111
//	//printf("%d\n",c);  //7
//
//	// ^ 按位异或
//	//相同为0，相异为1。
//	int a = 3;  //011
//	int b = 5;   //101
//	int c = a ^ b;  //110
//	printf("%d\n",c);  //6
//	return 0;
//}



//// 对于移位运算符，不要移动负数位，这个是标准未定义的。
//int num = 10;
//num >> -1;//error


////左移操作符 移位规则：左边抛弃、右边补0
////乘2的效果。
//int main()
//{
//	int a = 5;
//	//0000000 00000000 00000000 00000101
//	int b = a << 1;
//	printf("%d",b); //10
//	return 0;
//
//}



//int main()
//{
//	int a = -1;
//	//
//	//整数的二进制表示有三种：原码、反码、补码
//	//存储到内存的是补码
//	//1000000 00000000 00000000 00000001   - 原码
//	//1111111 11111111 11111111 11111110    - 反码
//	//1111111 11111111 11111111 11111111  - 补码
//	int b = a >> 1;
//	printf("%d\n", b);  //-1
//	return 0;
//}



////右移操作符 运算分两种：
////1. 逻辑移位 左边用0填充，右边丢弃
//
////2. 算术移位 左边用原该值的符号位填充，右边丢弃   (一般都是算术右移)
////减半的效果
//int main()
//{
//	int a = 16;
//	//>> -- 右移操作符
//	//移动的是二进制位
//	//10000   可以补齐00000000 00000000 00000000 00010000
//	int b = a >> 1;
//	printf("%d\n",b);   //8
//	return 0;
//}



////对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
////% 操作符的两个操作数必须为整数。返回的是整除之后的余数。
//int main()
//{
//	double a = 5 / 2.0;   //商2余1
//	//double a = 5 % 2.0;   //error   “%”: 非法，右操作数包含“double”类型
//	printf("a = %lf\n",a);
//	return 0;
//	
//}